import {
  Component,
  Input,
  OnInit,
  ViewChild,
  AfterViewInit,
} from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { Store } from '@ngrx/store';
import { BsModalRef } from 'ngx-bootstrap/modal';
import { Viewport } from 'pixi-viewport';
import * as PIXI from 'pixi.js';
import { Graphics } from 'pixi.js';
import { firstValueFrom } from 'rxjs';
import { AppState } from 'src/app/reducer/rootReducer';
import { IDropdown } from 'src/app/shared/models/IDropdown';
import { IPositionTypeBin } from 'src/app/shared/models/IPositionTypeBin';
import { lienarFunctionToSetZoomProportion } from 'src/app/shared/util/math';
import { WarehouseService } from 'src/app/warehouse/warehouse.service';
import { SetCurrentPositionTypeBin } from '../warehouse-redux/warehouseAction';

@Component({
  selector: 'app-modal-select-type-address',
  templateUrl: './modal-select-type-address.component.html',
  styleUrls: ['./modal-select-type-address.component.scss'],
})
export class ModalSelectTypeAddressComponent implements OnInit, AfterViewInit {
  @Input() title: string = '';
  @Input() gameInstance: any;
  @ViewChild('pixiContainer', { static: true }) pixiContainer: any;
  typeForm!: FormGroup;

  isRotated = false;

  positionTypeBins: IPositionTypeBin[] = [];
  positionTypeDropDown: IDropdown[] = [];

  positionTypeSelected: IPositionTypeBin | undefined = undefined;

  accessSideDropdown: IDropdown[] = [
    {
      text: 'Up',
      value: 0,
    },
    {
      text: 'Right',
      value: 1,
    },
    {
      text: 'Down',
      value: 2,
    },
    {
      text: 'Left',
      value: 3,
    },
  ];

  rows = 1;
  columns = 1;

  private app: PIXI.Application = new PIXI.Application({
    width: 350,
    height: 350,
    backgroundColor: 0xececec,
    antialias: true,
  });

  private viewport!: Viewport;

  constructor(
    public bsModalRef: BsModalRef,
    private warehouseService: WarehouseService,
    private store: Store<AppState>
  ) {}

  ngAfterViewInit(): void {
    this.pixiContainer.nativeElement.appendChild(this.app.view as any);

    this.viewport = new Viewport({
      screenHeight: 350,
      screenWidth: 350,
      worldHeight: 1000,
      worldWidth: 1000,
      events: this.app.renderer.events,
    });

    this.app.stage.addChild(this.viewport);

    this.viewport.drag().pinch().wheel();
    this.viewport.on('wheel', (arg: any) => {
      console.log(arg);
    });
  }
  ngOnInit(): void {
    this.loadPositionTypeBins();
    this.createTypeForm();
  }

  onSubmit(): void {
    if (!this.positionTypeSelected) return;

    const value = this.typeForm.value as IPositionTypeBin;
    value.totalDepth = this.positionTypeSelected.totalDepth;
    value.totalFront = this.positionTypeSelected.totalFront;

    this.store.dispatch(SetCurrentPositionTypeBin(value));
    this.gameInstance.SendMessage(
      'JavaScriptMessager',
      'HandleSpawnMode',
      'true'
    );
    this.closeModal();
  }

  closeModal(): void {
    this.bsModalRef.hide();
  }

  drawPreview(rows: number, columns: number): void {
    if (!this.positionTypeSelected) return;
    (this.app.stage.children[0] as Viewport).removeChildren();

    const graphicsArray: Graphics[] = [];

    let width = this.positionTypeSelected.totalFront * 100.0;
    let height = this.positionTypeSelected.totalDepth * 100.0;
    for (let i = 1; i <= 5; i++) {
      if (width >= this.app.view.width || height >= this.app.view.height) {
        width /= i;
        height /= i;
      } else break;
    }

    let position = [
      this.app.view.width / 2.0 - width / 2.0,
      this.app.view.height / 2.0 - height / 2.0,
    ];

    for (let x = 0; x < columns; x++) {
      for (let y = 0; y < rows; y++) {
        const graphics = new PIXI.Graphics();
        graphics.lineStyle(2, 0x00, 1);
        graphics.beginFill(0xfad985);
        graphics.drawRect(0, 0, width, height);
        graphics.endFill();
        graphics.position.set(
          position[0] + width * x,
          position[1] + height * y
        );
        graphicsArray.push(graphics);
        this.viewport.addChild(graphics);
      }
    }

    if (rows > 1 || columns > 1) {
      const rowByZoom = lienarFunctionToSetZoomProportion(rows);
      const zoomByColumn = lienarFunctionToSetZoomProportion(columns);
      this.viewport.setZoom(
        rowByZoom < zoomByColumn ? rowByZoom : zoomByColumn
      );

      console.log(graphicsArray.length / 2);
      this.viewport.moveCenter(
        graphicsArray[Math.ceil(graphicsArray.length / 2)].position.x,
        graphicsArray[Math.ceil(graphicsArray.length / 2)].position.y
      );
    } else {
      this.viewport.setZoom(1.0);
      if (graphicsArray[0])
        this.viewport.moveCenter(
          position[0] + graphicsArray[0].getBounds().width / 2,
          position[1] + graphicsArray[0].getBounds().height / 2
        );
    }
  }

  createTypeForm(): void {
    this.typeForm = new FormGroup({
      positionTypeDescription: new FormControl('', [Validators.required]),
      pickingAccess: new FormControl('0', [Validators.required]),
      rowCount: new FormControl('1', [Validators.required, Validators.min(1)]),
      columnCount: new FormControl('1', [
        Validators.required,
        Validators.min(1),
      ]),
      // stepByColumn: new FormControl('1', [
      //   Validators.required,
      //   Validators.min(1),
      // ]),
      // stepByRow: new FormControl('1', [Validators.required, Validators.min(1)]),
      // stepByRowSize: new FormControl('0', [
      //   Validators.required,
      //   Validators.min(0),
      // ]),
      // stepByColumnSize: new FormControl('0', [
      //   Validators.required,
      //   Validators.min(0),
      // ]),
    });

    this.typeForm
      .get('positionTypeDescription')
      ?.valueChanges.subscribe((selectedValue) => {
        this.positionTypeSelected = this.positionTypeBins.find(
          (x) => x.positionTypeDescription === selectedValue
        );
        this.drawPreview(1, 1);
      });

    this.typeForm.get('rowCount')?.valueChanges.subscribe((value) => {
      this.rows = +value;
      this.drawPreview(this.rows, this.columns);
    });

    this.typeForm.get('columnCount')?.valueChanges.subscribe((value) => {
      this.columns = +value;
      this.drawPreview(this.rows, this.columns);
    });
  }

  rotate(): void {
    if (!this.positionTypeSelected) return;

    if (!this.isRotated) {
      const front = this.positionTypeSelected.totalDepth;
      const depth = this.positionTypeSelected.totalFront;

      this.positionTypeSelected.totalFront = front;
      this.positionTypeSelected.totalDepth = depth;
    } else {
      const front = this.positionTypeSelected.totalDepth;
      const depth = this.positionTypeSelected.totalFront;

      this.positionTypeSelected.totalFront = front;
      this.positionTypeSelected.totalDepth = depth;
    }
    this.isRotated = !this.isRotated;
    this.drawPreview(1, 1);
  }

  async loadPositionTypeBins(): Promise<void> {
    try {
      this.positionTypeBins = await firstValueFrom(
        this.warehouseService.loadPositionTypeBins()
      );
      this.positionTypeBins.forEach((item) => {
        this.positionTypeDropDown.push({
          text: item.positionTypeDescription,
          value: item.positionTypeDescription,
        });
      });
      this.positionTypeSelected = this.positionTypeBins[0];
      this.drawPreview(1, 1);
      this.typeForm
        .get('positionTypeDescription')
        ?.setValue(this.positionTypeDropDown[0].value);
    } catch (error) {
      console.error(error);
    }
  }
}
