import {
  AfterViewInit,
  Component,
  ElementRef,
  EventEmitter,
  Input,
  OnInit,
  Output,
  ViewChild,
} from '@angular/core';
import { FormGroup } from '@angular/forms';
import { IDropdown } from 'src/app/shared/models/IDropdown';
import { ILayer } from 'src/app/shared/models/ILayer';
import * as PIXI from 'pixi.js';
import { ToastrService } from 'ngx-toastr';

@Component({
  selector: 'app-type-address-layer',
  templateUrl: './type-address-layer.component.html',
  styleUrls: ['./type-address-layer.component.scss'],
})
export class TypeAddressLayerComponent implements OnInit, AfterViewInit {
  @Input() typeForm!: FormGroup;

  layerDropdown: IDropdown[] = [];
  selectedLayer: ILayer | undefined = undefined;
  layers: ILayer[] = [];
  layerIndexName = 1;

  @ViewChild('pixiContainer', { static: true }) elementRef!: ElementRef;

  @Output() layersOut = new EventEmitter<{ layers: ILayer[] }>();

  private app: PIXI.Application | undefined;

  constructor(private toastr: ToastrService) {}

  ngAfterViewInit(): void {
    this.initPixi();
  }

  ngOnInit(): void {}

  addLayer(): void {
    // const lastLayer: ILayer = this.layers.slice[-1];
    // if (lastLayer) {
    //   locationY = lastLayer.locationY + lastLayer.totalHeight;
    // }

    let front = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalFront')?.value
    );
    if (Number.isNaN(front)) {
      front = 0;
    }

    // let totalHeight =
    //   Math.abs(
    //     parseFloat(
    //       this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    //     )
    //   ) /
    //   (this.layers.length + 1);

    // this.recalculateSizeOfEachLayer(totalHeight);

    let totalHeight = parseFloat(
      this.typeForm.get('layerForm')?.get('totalHeightLayer')?.value
    );

    let locationY = parseFloat(
      this.typeForm.get('layerForm')?.get('locationY')?.value
    );
    if (Number.isNaN(locationY)) locationY = 0;

    const layer: ILayer = {
      layerName: `L${this.layerIndexName++}`,
      locationX: 0,
      locationY: locationY,
      locationZ: 0,
      totalDepth: 0,
      bins: [],
      totalFront: front,
      totalHeight,
    };

    const postionTypeTotalHeight = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    );
    const y =
      this.div.clientHeight -
      4 -
      this.getLayerSize(layer.locationY, postionTypeTotalHeight);

    const relativeHeight = this.getLayerSize(
      layer.totalHeight,
      postionTypeTotalHeight
    );

    if (this.checkCollisionBetweenLayers(y, relativeHeight)) {
      this.toastr.warning('Two layers cannot overlay each others!');
      return;
    }

    if (
      this.isOverflowMaxHeight(locationY, totalHeight, postionTypeTotalHeight)
    ) {
      this.toastr.warning(
        'Height and position Y, cannot be over the max position type height'
      );
      return;
    }

    console.log(locationY);

    this.layers.push(layer);
    this.layerDropdown.push({
      text: layer.layerName,
      value: layer.layerName,
    });

    this.createLayerGraphic(layer);
    this.clearAllFields();
  }

  removeLayer(): void {
    const layerName = this.typeForm
      .get('layerForm')
      ?.get('layerDropdown')?.value;
    if (layerName) {
      this.layers.splice(
        this.layers.findIndex((x) => x.layerName === layerName),
        1
      );
      this.layerDropdown.splice(
        this.layerDropdown.findIndex((x) => x.value === layerName),
        1
      );

      const child = this.app?.stage.children.find((x) => x.name === layerName)!;
      this.app?.stage.removeChild(child);
    }

    this.clearAllFields();
  }

  updateLayer(): void {
    const layerName = this.typeForm.get('layerForm')?.get('layerName')?.value;

    const newLayerName = this.typeForm
      .get('layerForm')
      ?.get('layerDropdown')?.value;
    const height = parseFloat(
      this.typeForm.get('layerForm')?.get('totalHeightLayer')?.value
    );
    const locationY = parseFloat(
      this.typeForm.get('layerForm')?.get('locationY')?.value
    );

    // const isAlreadyInUse = this.layers.findIndex(
    //   (it) => it.layerName === newLayerName
    // );

    // if (isAlreadyInUse !== -1) {
    //   this.toastr.warning('Cannot use tha same in two layers!');
    //   return;
    // }

    const postionTypeTotalHeight = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    );
    if (this.checkCollisionBetweenLayers(locationY, height)) {
      this.toastr.warning('Two layers are overlay each other.');
      return;
    }

    if (this.isOverflowMaxHeight(locationY, height, postionTypeTotalHeight)) {
      this.toastr.warning(
        'Height and position Y, cannot be over the max position type height'
      );
      return;
    }

    const layer = this.layers.find((it) => it.layerName === layerName);
    if (layer) {
      layer.layerName = newLayerName;
      layer.locationY = locationY;
      layer.totalHeight = height;

      const layerDropdown = this.layerDropdown.find(
        (it) => it.value === layerName
      );
      if (layerDropdown) {
        layerDropdown.text = layerName;
        layerDropdown.value = layerName;
      }

      this.changeGraphics(layer, newLayerName);
      this.clearAllFields();
    }
  }

  clearAllFields(): void {
    this.layersOut.emit({ layers: this.layers });
    this.selectedLayer = undefined;
    this.typeForm.get('layerForm')?.get('layerName')?.reset();
    this.typeForm.get('layerForm')?.get('totalHeightLayer')?.reset(0.0);
    this.typeForm.get('layerForm')?.get('locationY')?.reset(0.0);
  }

  getLayerSize(totalHeightLayer: number, totalHeight: number): number {
    const res = (this.div.clientHeight * totalHeightLayer) / totalHeight;
    return res;
  }

  get totalHeight(): number {
    return parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    );
  }

  // private recalculateSizeOfEachLayer(newHeight: number): void {
  //   this.layers.forEach((item) => {
  //     item.totalHeight = newHeight;
  //   });
  // }

  onLayerSelect(graphic: PIXI.Graphics) {
    const layerName = graphic.name;
    console.log(this.layers);
    const layer = this.layers.find((it) => it.layerName === layerName);
    if (layer) {
      this.typeForm
        .get('layerForm')
        ?.get('totalHeightLayer')
        ?.setValue(layer.totalHeight.toString());

      this.typeForm
        .get('layerForm')
        ?.get('locationY')
        ?.setValue(layer.locationY.toString());
      this.typeForm
        .get('layerForm')
        ?.get('layerName')
        ?.setValue(layer.layerName);
      this.typeForm
        .get('layerForm')
        ?.get('layerDropdown')
        ?.setValue(layer.layerName);

      this.selectedLayer = layer;
    }
  }

  get div(): HTMLDivElement {
    return this.elementRef.nativeElement;
  }

  initPixi(): void {
    this.app = new PIXI.Application({
      width: this.div.clientWidth,
      height: this.div.clientHeight - 4,
      antialias: true,
      backgroundColor: 0xd3d3d3,
    });

    this.div.appendChild(this.app.view as any);
  }

  private createLayerGraphic(layer: ILayer): void {
    const postionTypeTotalHeight = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    );

    const y =
      this.div.clientHeight -
      4 -
      this.getLayerSize(layer.locationY, postionTypeTotalHeight);
    const relativeHeight = this.getLayerSize(
      layer.totalHeight,
      postionTypeTotalHeight
    );

    const text = new PIXI.Text(layer.layerName, {
      fontSize: 16,
      lineHeight: 28,
      letterSpacing: 0,
      fill: 0xffffff,
      align: 'center',
    });

    const graphic = new PIXI.Graphics();

    graphic.lineStyle(2, 0x000000, 1);
    graphic.beginFill(0x035e09);
    graphic.drawRect(0, 0, this.div.clientWidth, relativeHeight);
    graphic.endFill();
    graphic.addChild(text);

    text.resolution = 10;
    text.position.x = this.div.clientWidth / 2.0;
    graphic.y = y - relativeHeight;

    graphic.interactive = true;
    graphic.name = layer.layerName;
    graphic.height = relativeHeight;
    graphic.onclick = () => {
      this.onLayerSelect(graphic);
    };

    this.app?.stage.addChild(graphic);
  }

  private changeGraphics(layer: ILayer, newLayerName: string): void {
    const graphic = this.app?.stage.getChildByName(
      layer.layerName
    ) as PIXI.Graphics;

    const postionTypeTotalHeight = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    );

    if (graphic) {
      const y =
        this.div.clientHeight -
        4 -
        this.getLayerSize(layer.locationY, postionTypeTotalHeight);

      const relativeHeight = this.getLayerSize(
        layer.totalHeight,
        postionTypeTotalHeight
      );

      graphic.name = newLayerName;
      graphic.y = y;

      graphic.clear();
      graphic.lineStyle(2, 0x000000, 1);
      graphic.beginFill(0x035e09);
      graphic.drawRect(0, 0, this.div.clientWidth, relativeHeight);
      graphic.endFill();
    }
  }

  private checkCollisionBetweenLayers(y: number, height: number): boolean {
    for (let i = 0; i < this.app!.stage.children.length; i++) {
      const graphics = this.app!.stage.getChildAt(i);
      if (
        graphics.y < y + height &&
        graphics.getLocalBounds().height + graphics.y > y
      )
        return true;
    }
    return false;
  }

  private isOverflowMaxHeight(y: number, height: number, max: number): boolean {
    if (y + height > max) return true;
    return false;
  }
}
