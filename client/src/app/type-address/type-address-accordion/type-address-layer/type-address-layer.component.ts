import {
  AfterViewInit,
  Component,
  ElementRef,
  EventEmitter,
  Input,
  OnInit,
  Output,
  ViewChild,
} from '@angular/core';
import { FormGroup } from '@angular/forms';
import { IDropdown } from 'src/app/shared/models/IDropdown';
import { ILayer } from 'src/app/shared/models/ILayer';
import * as PIXI from 'pixi.js';
import { ToastrService } from 'ngx-toastr';

@Component({
  selector: 'app-type-address-layer',
  templateUrl: './type-address-layer.component.html',
  styleUrls: ['./type-address-layer.component.scss'],
})
export class TypeAddressLayerComponent implements OnInit, AfterViewInit {
  @Input() typeForm!: FormGroup;

  layerDropdown: IDropdown[] = [
    {text: '1', value: '1'},{text: '2', value: '2'},{text: '3', value: '3'},{text: '4', value: '4'},{text: '5', value: '5'},{text: '6', value: '6'},{text: '7', value: '7'},{text: '8', value: '8'},{text: '9', value: '9'},{text: '10', value: '10'},{text: '11', value: '11'},{text: '12', value: '12'},{text: '13', value: '13'},{text: '14', value: '14'},{text: '15', value: '15'},{text: '16', value: '16'},{text: '17', value: '17'},{text: '18', value: '18'},{text: '19', value: '19'},{text: '20', value: '20'},
  ];
  selectedLayer: ILayer | undefined = undefined;
  layers: ILayer[] = [];
  layerIndexName = 1;

  width = 500;
  height = 500;

  @ViewChild('pixiContainer', { static: true }) elementRef!: ElementRef;

  @Output() layersOut = new EventEmitter<{ layers: ILayer[] }>();
  @Output() layersDropdownOut = new EventEmitter<{
    layersDropdown: IDropdown[];
  }>();

  private app: PIXI.Application | undefined;

  constructor(private toastr: ToastrService) {}

  ngAfterViewInit(): void {
    this.initPixi();
  }

  ngOnInit(): void {
    this.typeForm
      .get('layerForm')
      ?.get('layerDropdown')
      ?.valueChanges.subscribe((value) => {
        const layer = this.layers.find((it) => it.layerDescription === value);
        if (layer) this.selectedLayer = layer;
      });
  }

  addLayer(): void {
    // const lastLayer: ILayer = this.layers.slice[-1];
    // if (lastLayer) {
    //   locationY = lastLayer.locationY + lastLayer.totalHeight;
    // }
    let layerDescription = this.typeForm.get('layerForm')?.get('layerDescription')?.value;
    let front = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalFront')?.value
    );
    if (Number.isNaN(front)) {
      front = 0;
    }

    // let totalHeight =
    //   Math.abs(
    //     parseFloat(
    //       this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    //     )
    //   ) /
    //   (this.layers.length + 1);

    // this.recalculateSizeOfEachLayer(totalHeight);

    let totalHeight = parseFloat(
      this.typeForm.get('layerForm')?.get('totalHeightLayer')?.value
    );

    let locationY = parseFloat(
      this.typeForm.get('layerForm')?.get('locationY')?.value
    );

    const positionTypeTotalDepth = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalDepth')?.value
    );

    const layer: ILayer = {
      layerDescription,
      locationX: 0,
      locationY: locationY,
      locationZ: 0,
      totalDepth: positionTypeTotalDepth,
      bins: [],
      totalFront: front,
      totalHeight,
    };

    const postionTypeTotalHeight = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    );
    const y =
      this.height -
      4 -
      this.getLayerSize(layer.locationY, postionTypeTotalHeight);

    const relativeHeight = this.getLayerSize(
      layer.totalHeight,
      postionTypeTotalHeight
    );

    if (this.checkCollisionBetweenLayers(y, relativeHeight)) {
      this.toastr.warning('Two layers cannot overlay each others!');
      return;
    }

    if (
      this.isOverflowMaxHeight(locationY, totalHeight, postionTypeTotalHeight)
    ) {
      this.toastr.warning(
        'Height and position Y, cannot be over the max position type height'
      );
      return;
    }

    this.layers.push(layer);
    this.layerDropdown.push({
      text: layer.layerDescription,
      value: layer.layerDescription,
    });

    this.createLayerGraphic(layer);
    this.clearAllFields();
  }

  removeLayer(): void {
    const layerDescription = this.typeForm
      .get('layerForm')
      ?.get('layerDropdown')?.value;
    if (layerDescription) {
      this.layers.splice(
        this.layers.findIndex((x) => x.layerDescription === layerDescription),
        1
      );
      this.layerDropdown.splice(
        this.layerDropdown.findIndex((x) => x.value === layerDescription),
        1
      );

      const child = this.app?.stage.children.find((x) => x.name === layerDescription)!;
      this.app?.stage.removeChild(child);
    }

    this.clearAllFields();
  }

  updateLayer(): void {
    const layerDescription = this.typeForm
      .get('layerForm')
      ?.get('layerDropdown')?.value;

    const newlayerDescription = this.typeForm
      .get('layerForm')
      ?.get('layerDescription')?.value;
    const height = parseFloat(
      this.typeForm.get('layerForm')?.get('totalHeightLayer')?.value
    );
    const locationY = parseFloat(
      this.typeForm.get('layerForm')?.get('locationY')?.value
    );

    // const isAlreadyInUse = this.layers.findIndex(
    //   (it) => it.layerDescription === newlayerDescription
    // );

    // if (isAlreadyInUse !== -1) {
    //   this.toastr.warning('Cannot use tha same in two layers!');
    //   return;
    // }

    const postionTypeTotalHeight = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    );
    if (this.checkCollisionBetweenLayers(locationY, height)) {
      this.toastr.warning('Two layers are overlay each other.');
      return;
    }

    if (this.isOverflowMaxHeight(locationY, height, postionTypeTotalHeight)) {
      this.toastr.warning(
        'Height and position Y, cannot be over the max position type height'
      );
      return;
    }

    const layer = this.layers.find((it) => it.layerDescription === layerDescription);
    if (layer) {
      layer.layerDescription = newlayerDescription;
      layer.locationY = locationY;
      layer.totalHeight = height;

      const layerDropdown = this.layerDropdown.find(
        (it) => it.value === layerDescription
      );
      if (layerDropdown) {
        layerDropdown.text = layerDescription;
        layerDropdown.value = layerDescription;
      }

      this.changeGraphics(layer, newlayerDescription);
      this.clearAllFields();
    }
  }

  clearAllFields(): void {
    this.layersDropdownOut.emit({ layersDropdown: this.layerDropdown });
    this.layersOut.emit({ layers: this.layers });
    this.selectedLayer = undefined;
    this.typeForm.get('layerForm')?.get('layerDescription')?.reset();
    this.typeForm.get('layerForm')?.get('totalHeightLayer')?.reset(0.0);
    this.typeForm.get('layerForm')?.get('locationY')?.reset(0.0);
  }

  getLayerSize(totalHeightLayer: number, totalHeight: number): number {
    const res = (this.height * totalHeightLayer) / totalHeight;
    return res;
  }

  get totalHeight(): number {
    return parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    );
  }

  onLayerSelect(graphic: PIXI.Graphics) {
    const layerDescription = graphic.name;
    const layer = this.layers.find((it) => it.layerDescription === layerDescription);
    if (layer) {
      this.typeForm
        .get('layerForm')
        ?.get('totalHeightLayer')
        ?.setValue(layer.totalHeight.toString());

      this.typeForm
        .get('layerForm')
        ?.get('locationY')
        ?.setValue(layer.locationY.toString());
      this.typeForm
        .get('layerForm')
        ?.get('layerDescription')
        ?.setValue(layer.layerDescription);
      this.typeForm
        .get('layerForm')
        ?.get('layerDropdown')
        ?.setValue(layer.layerDescription);

      this.selectedLayer = layer;
    }
  }

  get div(): HTMLDivElement {
    return this.elementRef.nativeElement;
  }

  initPixi(): void {
    console.log(this.width, this.height);

    this.app = new PIXI.Application({
      width: this.width,
      height: this.height,
      antialias: true,
      backgroundColor: 0xd3d3d3,
    });

    this.div.appendChild(this.app.view as any);
  }

  private createLayerGraphic(layer: ILayer): void {
    const postionTypeTotalHeight = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    );

    const y =
      this.height -
      4 -
      this.getLayerSize(layer.locationY, postionTypeTotalHeight);
    const relativeHeight = this.getLayerSize(
      layer.totalHeight,
      postionTypeTotalHeight
    );

    const text = new PIXI.Text(layer.layerDescription, {
      fontSize: 16,
      lineHeight: 28,
      letterSpacing: 0,
      fill: 0xffffff,
      align: 'center',
    });
    console.log(relativeHeight, y - relativeHeight);

    const graphic = new PIXI.Graphics();

    graphic.lineStyle(2, 0x000000, 1);
    graphic.beginFill(0x035e09);
    graphic.drawRect(0, 0, this.width, relativeHeight);
    graphic.endFill();
    graphic.addChild(text);

    text.resolution = 10;
    text.position.x = this.width / 2.0;
    graphic.y = y - relativeHeight;

    graphic.interactive = true;
    graphic.name = layer.layerDescription;
    // graphic.height = relativeHeight;
    graphic.onclick = () => {
      this.onLayerSelect(graphic);
    };

    this.app?.stage.addChild(graphic);
  }

  private changeGraphics(layer: ILayer, newlayerDescription: string): void {
    const graphic = this.app?.stage.getChildByName(
      layer.layerDescription
    ) as PIXI.Graphics;

    const postionTypeTotalHeight = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalHeight')?.value
    );

    if (graphic) {
      const y =
        this.height -
        4 -
        this.getLayerSize(layer.locationY, postionTypeTotalHeight);

      const relativeHeight = this.getLayerSize(
        layer.totalHeight,
        postionTypeTotalHeight
      );

      graphic.name = newlayerDescription;
      graphic.y = y - relativeHeight;

      graphic.clear();
      graphic.lineStyle(2, 0x000000, 1);
      graphic.beginFill(0x035e09);
      graphic.drawRect(0, 0, this.width, relativeHeight);
      graphic.endFill();
    }
  }

  private checkCollisionBetweenLayers(y: number, height: number): boolean {
    for (let i = 0; i < this.app!.stage.children.length; i++) {
      const graphics = this.app!.stage.getChildAt(i);
      if (
        graphics.y < y - height &&
        graphics.getLocalBounds().height - graphics.y > y
      )
        return true;
    }
    return false;
  }

  private isOverflowMaxHeight(y: number, height: number, max: number): boolean {
    if (y + height > max) return true;
    return false;
  }
}
