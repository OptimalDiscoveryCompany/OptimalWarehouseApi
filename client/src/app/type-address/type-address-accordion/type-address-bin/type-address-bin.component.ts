import {
  Component,
  EventEmitter,
  Input,
  OnInit,
  Output,
  ViewChild,
  ElementRef,
  AfterViewInit,
  OnChanges,
  SimpleChanges,
} from '@angular/core';
import { FormGroup } from '@angular/forms';
import { IBin } from 'src/app/shared/models/IBin';
import { IDropdown } from 'src/app/shared/models/IDropdown';
import * as PIXI from 'pixi.js';
import { ToastrService } from 'ngx-toastr';
import { ILayer } from 'src/app/shared/models/ILayer';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-type-address-bin',
  templateUrl: './type-address-bin.component.html',
  styleUrls: ['./type-address-bin.component.scss'],
})
export class TypeAddressBinComponent
  implements OnInit, AfterViewInit, OnChanges
{
  @Input() typeForm!: FormGroup;
  @Input() layers!: ILayer[];
  @ViewChild('pixiContainerBin', { static: true }) elementRef!: ElementRef;
  @Output() binsOut = new EventEmitter<{ bins: IBin[] }>();

  bins: IBin[] = [];
  layerDropdown: IDropdown[] = [];
  binsDropdown: IDropdown[] = [];
  selectedBin: IBin | undefined;
  selectedLayer: ILayer | undefined;
  app: PIXI.Application | undefined;
  binIndex = 0;

  constructor(private toastr: ToastrService) {}

  ngOnInit(): void {}

  ngAfterViewInit(): void {
    this.initPixi();
  }
  ngOnChanges(changes: SimpleChanges): void {
    console.log(changes)
    if (changes['layers']) {
      this.layers.forEach((it) => {
        this.layerDropdown = [];
        this.layerDropdown.push({
          text: it.layerName,
          value: it.layerName,
        });
      });
    }
  }

  getBinSize(totalFrontBin: number, totalFront: number): number {
    const res = (this.div.clientWidth * totalFrontBin) / totalFront;
    return res;
  }

  private initPixi(): void {
    this.app = new PIXI.Application({
      width: this.div.clientWidth,
      height: this.div.clientHeight - 4,
      antialias: true,
      backgroundColor: 0xd3d3d3,
    });

    this.div.appendChild(this.app.view as any);
  }

  addBin(): void {
    if (!this.selectedLayer) {
      this.toastr.warning('Select layer!');
      return;
    }

    const height = parseFloat(
      this.typeForm.get('binForm')?.get('totalHeight')?.value
    );
    const front = parseFloat(
      this.typeForm.get('binForm')?.get('totalFront')?.value
    );
    const locationX = parseFloat(
      this.typeForm.get('binForm')?.get('locationX')?.value
    );

    const angle = parseFloat(this.typeForm.get('binForm')?.get('angle')?.value);

    const positionTypeTotalDepth = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalDepth')?.value
    );

    const bin: IBin = {
      binName: `B${this.binIndex++}`,
      angle,
      locationY: 0,
      locationZ: 0,
      locationX,
      images: [],
      products: [],
      totalDepth: positionTypeTotalDepth,
      totalFront: front,
      totalHeight: height,
    };

    const positionTypeTotalFront = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalFront')?.value
    );
    const x = this.getBinSize(bin.locationX, positionTypeTotalFront);
    const relativeFront = this.getBinSize(
      bin.totalFront,
      positionTypeTotalFront
    );

    if (this.checkCollisionBetweenBins(x, relativeFront)) {
      this.toastr.warning('Two bins cannot overlay each others!');
      return;
    }

    if (this.isOverflowMaxWidth(locationX, front, positionTypeTotalFront)) {
      this.toastr.warning(
        'Width and position X, cannot be over the max position type width!'
      );
      return;
    }

    this.bins.push(bin);
    this.binsDropdown.push({
      text: bin.binName,
      value: bin.binName,
    });

    this.createBinsGraphic(bin);
    this.clearAllFields();
  }

  clearAllFields(): void {
    this.binsOut.emit({ bins: this.bins });
    this.selectedBin = undefined;
    this.typeForm.get('binForm')?.get('binName')?.reset();
    this.typeForm.get('binForm')?.get('totalHeight')?.reset(0.0);
    this.typeForm.get('binForm')?.get('totalFront')?.reset(0.0);
    this.typeForm.get('binForm')?.get('locationX')?.reset(0.0);
  }

  private createBinsGraphic(bin: IBin): void {
    const positionTypeTotalFront = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalFront')?.value
    );

    const x = this.getBinSize(bin.locationX, positionTypeTotalFront);
    const relativeFront = this.getBinSize(
      bin.totalFront,
      positionTypeTotalFront
    );

    const text = new PIXI.Text(bin.binName, {
      fontSize: 16,
      lineHeight: 28,
      letterSpacing: 0,
      fill: 0xffffff,
      align: 'center',
    });
    text.resolution = 10;
    text.position.x = this.div.clientWidth / 2.0;

    const graphic = new PIXI.Graphics();
    graphic.lineStyle(2, 0x000000, 1);
    graphic.beginFill(0x035e09);
    graphic.drawRect(0, 0, relativeFront, this.div.clientHeight - 10);
    graphic.endFill();
    graphic.addChild(text);

    graphic.position.x = x;
    graphic.interactive = true;
    graphic.name = bin.binName;
    graphic.width = relativeFront;

    this.app?.stage.addChild(graphic);
  }

  private checkCollisionBetweenBins(x: number, width: number): boolean {
    for (let i = 0; i < this.app!.stage.children.length; i++) {
      const graphics = this.app!.stage.getChildAt(i);
      if (
        graphics.x < x + width &&
        graphics.x + graphics.getLocalBounds().width > x
      )
        return true;
    }
    return false;
  }

  private isOverflowMaxWidth(x: number, width: number, max: number): boolean {
    if (x + width > max) return true;
    return false;
  }

  get div(): HTMLDivElement {
    return this.elementRef.nativeElement;
  }
}
