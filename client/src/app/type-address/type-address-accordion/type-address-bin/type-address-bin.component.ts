import {
  Component,
  EventEmitter,
  Input,
  OnInit,
  Output,
  ViewChild,
  ElementRef,
  AfterViewInit,
  OnChanges,
  SimpleChanges,
} from '@angular/core';
import { FormGroup } from '@angular/forms';
import { IBin } from 'src/app/shared/models/IBin';
import { IDropdown } from 'src/app/shared/models/IDropdown';
import * as PIXI from 'pixi.js';
import { ToastrService } from 'ngx-toastr';
import { ILayer } from 'src/app/shared/models/ILayer';

@Component({
  selector: 'app-type-address-bin',
  templateUrl: './type-address-bin.component.html',
  styleUrls: ['./type-address-bin.component.scss'],
})
export class TypeAddressBinComponent implements OnInit, AfterViewInit {
  @Input() typeForm!: FormGroup;
  @Input() layers!: ILayer[];
  @Input() layerDropdown!: IDropdown[];

  @Output() binsOut = new EventEmitter<{ bins: IBin[] }>();

  @ViewChild('pixiContainerBin', { static: true }) elementRef!: ElementRef;

  bins: IBin[] = [];
  binsDropdown: IDropdown[] = [];
  selectedBin: IBin | undefined;
  selectedLayer: ILayer | undefined;
  app: PIXI.Application | undefined;
  binIndex = 0;

  width = 1258;
  height = 192;

  layerTotalHeight = 5.0;

  constructor(private toastr: ToastrService) {}

  ngOnInit(): void {
    this.typeForm
      .get('binForm')
      ?.get('layerDropdownBin')
      ?.valueChanges.subscribe((value) => {
        const layer = this.layers.find((it) => it.layerDescription === value);
        this.clearCanvas();
        if (layer) {
          this.selectedLayer = layer;
          this.bins = layer.bins;
          this.layerTotalHeight = this.getAboveLayer();
          this.binsDropdown = this.bins.map((it) => {
            return {
              text: it.binDescription,
              value: it.binDescription,
            };
          });
          this.loadCanvas();
        }
      });

    this.typeForm
      .get('binForm')
      ?.get('binDropdown')
      ?.valueChanges.subscribe((value) => {
        const bin = this.bins.find((it) => it.binDescription === value);
        if (bin) this.selectedBin = bin;
      });
  }

  ngAfterViewInit(): void {
    this.initPixi();
  }

  getBinSize(
    valueBasesOn: number,
    totalFrontBin: number,
    totalFront: number
  ): number {
    const res = (valueBasesOn * totalFrontBin) / totalFront;
    return res;
  }

  private initPixi(): void {
    console.log(this.width, this.height);
    this.app = new PIXI.Application({
      width: this.width,
      height: this.height,
      antialias: true,
      backgroundColor: 0xd3d3d3,
    });

    this.div.appendChild(this.app.view as any);
  }

  addBin(): boolean {
    const bin = this.validateBin();
    if (!bin) return false;
    this.bins.push(bin);
    this.binsDropdown.push({
      text: bin.binDescription,
      value: bin.binDescription,
    });

    this.createBinsGraphic(bin);
    this.clearAllFields();

    return true;
  }

  updateBin(): void {
    if (!this.selectedBin) {
      this.toastr.warning('Select one bin!');
      return;
    }
    const bin = this.validateBin();
    if (!bin) return;
    this.removeGraphics();
    this.removeBinFromArray();

    this.bins.push(bin);
    this.binsDropdown.push({
      text: bin.binDescription,
      value: bin.binDescription,
    });

    this.createBinsGraphic(bin);
    this.clearAllFields();
  }

  removeBin() {
    if (!this.selectedBin) {
      this.toastr.warning('Select one bin!');
      return;
    }
    this.removeGraphics();
    this.removeBinFromArray();
    this.clearAllFields();
  }

  private validateBin(): IBin | null {
    if (!this.selectedLayer) {
      this.toastr.warning('Select layer!');
      return null;
    }


    const height = parseFloat(
      this.typeForm.get('binForm')?.get('totalHeight')?.value
    );
    const front = parseFloat(
      this.typeForm.get('binForm')?.get('totalFront')?.value
    );
    const locationX = parseFloat(
      this.typeForm.get('binForm')?.get('locationX')?.value
    );

    const positionTypeTotalFront = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalFront')?.value
    );
    const angle = parseFloat(this.typeForm.get('binForm')?.get('angle')?.value);

    const positionTypeTotalDepth = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalDepth')?.value
    );

    const binDescription = this.typeForm
      .get('binForm')
      ?.get('binDescription')?.value;

    const bin: IBin = {
      binDescription,
      angle,
      locationY: 0,
      locationZ: 0,
      locationX,
      images: [],
      products: [],
      totalDepth: positionTypeTotalDepth,
      totalFront: front,
      totalHeight: height,
    };

    const x = this.getBinSize(
      this.width,
      bin.locationX,
      positionTypeTotalFront
    );
    const relativeFront = this.getBinSize(
      this.width,
      bin.totalFront,
      positionTypeTotalFront
    );

    if (this.checkCollisionBetweenBins(x, relativeFront, bin.binDescription)) {
      this.toastr.warning('Two bins cannot overlay each others!');
      return null;
    }

    if (this.isOverflowMaxWidth(locationX, front, positionTypeTotalFront)) {
      this.toastr.warning(
        'Width and position X, cannot be over the max position type width!'
      );
      return null;
    }

    return bin;
  }

  clearAllFields(): void {
    this.selectedLayer!.bins = this.bins;
    this.binsOut.emit({ bins: this.bins });
    this.selectedBin = undefined;
    this.typeForm.get('binForm')?.get('binDescription')?.reset();
    this.typeForm.get('binForm')?.get('totalHeight')?.reset(0.0);
    this.typeForm.get('binForm')?.get('totalFront')?.reset(0.0);
    this.typeForm.get('binForm')?.get('locationX')?.reset(0.0);
  }

  private euclideanDistance(y1: number, y2: number): number {
    return Math.sqrt(Math.pow(y2 - y1, 2));
  }
  private getAboveLayer(): number {
    const layersAbove: ILayer[] = [];
    let closestLayer = 5.0;

    this.layers.forEach((it) => {
      if (this.selectedLayer!.locationY < it.locationY) layersAbove.push(it);
    });

    let dist = 99999999;
    if (layersAbove.length === 0) return closestLayer;
    layersAbove.forEach((it) => {
      const res = this.euclideanDistance(
        this.selectedLayer!.locationY,
        it.locationY
      );
      if (res < dist) dist = res;
    });
    closestLayer = dist;
    return closestLayer;
  }

  private removeBinFromArray(): void {
    const binDescription = this.selectedBin?.binDescription;
    this.binsDropdown.splice(
      this.binsDropdown.findIndex((it) => it.value === binDescription),
      1
    );
    this.bins.splice(
      this.bins.findIndex((it) => it.binDescription === binDescription)
    );
  }

  private onSelectBin(graphic: PIXI.Graphics): void {
    const binDescription = graphic.name;
    const bin = this.bins.find((it) => it.binDescription === binDescription);
    if (bin) {
      this.typeForm
        .get('binForm')
        ?.get('binDescription')
        ?.setValue(bin.binDescription);
      this.typeForm
        .get('binForm')
        ?.get('totalHeight')
        ?.setValue(bin.totalHeight.toString());
      this.typeForm
        .get('binForm')
        ?.get('totalFront')
        ?.setValue(bin.totalFront.toString());
      this.typeForm
        .get('binForm')
        ?.get('locationX')
        ?.setValue(bin.locationX.toString());

      this.selectedBin = bin;
    }
  }

  private createBinsGraphic(bin: IBin): void {
    const positionTypeTotalFront = parseFloat(
      this.typeForm.get('addressPostionTypeForm')?.get('totalFront')?.value
    );

    const x = this.getBinSize(
      this.width,
      bin.locationX,
      positionTypeTotalFront
    );
    const relativeFront = this.getBinSize(
      this.width,
      bin.totalFront,
      positionTypeTotalFront
    );
    const relativeHeight = this.getBinSize(
      this.height,
      bin.totalHeight,
      this.layerTotalHeight
    );

    const text = new PIXI.Text(bin.binDescription, {
      fontSize: 16,
      lineHeight: 28,
      letterSpacing: 0,
      fill: 0xffffff,
      align: 'center',
    });
    text.resolution = 10;
    text.position.x = relativeFront / 2.0;

    const graphic = new PIXI.Graphics();
    graphic.lineStyle(2, 0x000000, 1);
    graphic.beginFill(0x035e09);
    graphic.drawRect(0, 0, relativeFront, relativeHeight);
    graphic.endFill();
    graphic.addChild(text);

    graphic.position.y = this.height - relativeHeight;
    graphic.position.x = x;
    graphic.interactive = true;
    graphic.onclick = () => {
      this.onSelectBin(graphic);
    };
    graphic.name = bin.binDescription;
    graphic.width = relativeFront;

    this.app?.stage.addChild(graphic);
  }

  private removeGraphics() {
    if (this.selectedBin) {
      const graphic = this.app!.stage.getChildByName(
        this.selectedBin.binDescription
      );
      this.app?.stage.removeChild(graphic);
    }
  }

  private loadCanvas() {
    this.bins.forEach((bin) => {
      this.createBinsGraphic(bin);
    });
  }

  private clearCanvas() {
    this.app!.stage.children.forEach((child) => {
      console.log(child);
      this.app!.stage.removeChild(child);
    });
  }

  private checkCollisionBetweenBins(
    x: number,
    width: number,
    name: string
  ): boolean {
    for (let i = 0; i < this.app!.stage.children.length; i++) {
      const graphics = this.app!.stage.getChildAt(i);
      if (graphics.name === name) continue;
      if (
        graphics.x < x + width &&
        graphics.x + graphics.getLocalBounds().width - 2 > x
      )
        return true;
    }
    return false;
  }

  private isOverflowMaxWidth(x: number, width: number, max: number): boolean {
    if (x + width > max) return true;
    return false;
  }

  get div(): HTMLDivElement {
    return this.elementRef.nativeElement;
  }
}
