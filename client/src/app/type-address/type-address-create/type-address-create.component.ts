import { Component, OnDestroy, OnInit } from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { Observable, Subject, Subscription } from 'rxjs';
import { ToastrService } from 'ngx-toastr';
import { v4 as uuidv4 } from 'uuid';

import { TypeAddressService } from '../type-address.service';
import { IBin } from 'src/app/shared/models/IBin';
import { ILayer } from 'src/app/shared/models/ILayer';
import { IPositionTypeMaster } from 'src/app/shared/models/IPositionTypeBin';
import { UnitService } from 'src/app/shared/components/unit/unit.service';
import {
  convertInchesToMeters,
  convertMetersToInches,
} from 'src/app/shared/util/unitConversion';

@Component({
  selector: 'app-type-address-create',
  templateUrl: './type-address-create.component.html',
  styleUrls: ['./type-address-create.component.scss'],
})
export class TypeAddressCreateComponent implements OnInit, OnDestroy {
  layers: ILayer[] = [];
  bins: IBin[] = [];

  layerGroundOffset = 0;

  binSeparationOffset = 0;
  layerSeparation = 0;

  actualLayerCount = 0;
  actualBinCount = 0;

  typeForm!: FormGroup;
  selectedType: string = 'floor';

  gameInstance: any;

  unitSystem = 'm';

  unitSystemSub?: Subscription;

  private gameInstanceSubject = new Subject<any>();
  gameInstance$: Observable<any> = this.gameInstanceSubject.asObservable();

  isSubdivision = false;

  subscription = this.gameInstance$.subscribe(() => {
    this.gameInstance.SendMessage(
      'EventManager',
      'SelectPositionTypePrefab',
      this.selectedType
    );

    if (this.id !== -1) {
      this.typeAddressService
        .loadPositionTypeById(this.id)
        .subscribe((value) => {
          this.typeForm.patchValue(value);
          if (this.unitSystem === 'in') {
            const totalFront = convertMetersToInches(value.totalFront);
            const totalDepth = convertMetersToInches(value.totalDepth);
            const totalHeight = convertMetersToInches(value.totalHeight);

            this.typeForm.patchValue({
              totalFront,
              totalDepth,
              totalHeight,
            });
          }

          this.typeForm
            .get('positionColor')!
            .setValue('#' + value.positionColor.toString(16));

          value.layers.forEach((layer) => {
            layer.uuid = uuidv4();
            layer.bins.forEach((bin) => {
              bin.uuid = uuidv4();
            });
          });

          this.positionType = value;
          this.layers = value.layers;
          this.bins = value.layers[0].bins;

          this.actualLayerCount = this.layers.length;
          this.actualBinCount = this.bins.length;

          if (this.positionType.type !== 'floor') {
            this.layerGroundOffset = this.layers[0].locationY;
            this.loadLayers();
          }
          if (this.positionType.type === 'bin') {
            this.binSeparationOffset = this.bins[0].locationZ;
            this.loadBins();
          }
        });
    }
  });

  positionType: IPositionTypeMaster | undefined;

  id = -1;

  constructor(
    private route: Router,
    private activeRoute: ActivatedRoute,
    private toastr: ToastrService,
    private typeAddressService: TypeAddressService,
    private unitService: UnitService
  ) {}

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
    this.unitSystemSub?.unsubscribe();
  }

  ngOnInit(): void {
    this.initForm();
    const id = this.activeRoute.snapshot.paramMap.get('id');
    if (id) {
      this.id = parseInt(id);
    }

    if (this.unitService.value) {
      this.unitSystem = 'in';
    } else {
      this.unitSystem = 'm';
    }

    this.unitSystemSub = this.unitService.unit$.subscribe((unit) => {
      if (this.unitSystem === 'in' && unit) return;
      else if (this.unitSystem === 'm' && !unit) return;

      const value = this.typeForm.value;
      const layers = [...this.layers];
      const bins = [...this.bins];

      if (unit) {
        this.unitSystem = 'in';
        const totalFront = convertMetersToInches(value.totalFront);
        const totalDepth = convertMetersToInches(value.totalDepth);
        const totalHeight = convertMetersToInches(value.totalHeight);

        this.typeForm.patchValue({
          totalFront,
          totalDepth,
          totalHeight,
        });
      } else {
        this.unitSystem = 'm';
        const totalFront = convertInchesToMeters(value.totalFront);
        const totalDepth = convertInchesToMeters(value.totalDepth);
        const totalHeight = convertInchesToMeters(value.totalHeight);
        this.typeForm.patchValue({
          totalFront,
          totalDepth,
          totalHeight,
        });
      }
      this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
      this.gameInstance.SendMessage('EventManager', 'RemoveBins');

      this.layers = layers;
      this.bins = bins;

      this.actualLayerCount = this.layers.length;
      this.actualBinCount = this.bins.length;

      if (value.type !== 'floor') {
        this.layerGroundOffset = this.layers[0].locationY;
        this.loadLayers();
      }
      if (value.type === 'bin') {
        this.binSeparationOffset = this.bins[0].locationZ;
        this.loadBins();
      }
    });
  }

  private setLayerAndBinToFloor(positionType: IPositionTypeMaster): void {
    this.bins.push({
      binDescription: 'B01',
      totalFront: 1,
      totalHeight: 1.3,
      totalDepth: 1.2,
      angle: 0,
      locationX: 0,
      locationY: 0,
      locationZ: 0,
      images: [],
      products: [],
    });

    this.layers.push({
      layerDescription: 'L01',
      totalFront: positionType.totalFront,
      totalHeight: positionType.totalHeight,
      totalDepth: positionType.totalDepth,
      locationX: 0,
      locationY: 0,
      locationZ: 0,
      bins: [],
      availableSpace: positionType.totalHeight,
    });
  }

  private setBinsToRack(): void {
    this.bins.push({
      binDescription: 'B01',
      totalFront: 1,
      totalHeight: 1.3,
      totalDepth: 1.2,
      angle: 0,
      locationX: 0,
      locationY: 0,
      locationZ: 0,
      images: [],
      products: [],
    });
  }

  submit(): void {
    this.positionType = this.typeForm.value as IPositionTypeMaster;

    this.positionType.positionColor = parseInt(
      this.typeForm.get('positionColor')!.value.toString().replace('#', ''),
      16
    );
    if (this.positionType.type === 'floor')
      this.setLayerAndBinToFloor(this.positionType);
    else if (this.positionType.type === 'rack') this.setBinsToRack();
    else {
      this.bins[0].locationZ = this.binSeparationOffset;
    }

    this.layers.forEach((layer) => {
      layer.bins = this.bins;
    });
    this.positionType.layers = this.layers;
    if (this.id === -1) {
      this.typeAddressService.savePositionType(this.positionType).subscribe({
        complete: () => {
          this.route.navigate(['typeaddress']);
        },
        error: (err) => console.error(err),
      });
    } else {
      this.typeAddressService
        .updatePositionType(this.id, this.positionType)
        .subscribe({
          complete: () => {
            this.route.navigate(['typeaddress']);
          },
          error: (err) => console.error(err),
        });
    }
  }

  initForm(): void {
    let totalValue = 1.0;
    if (this.unitService.value) totalValue = convertMetersToInches(totalValue);

    this.typeForm = new FormGroup({
      type: new FormControl(this.selectedType, [Validators.required]),
      positionTypeDescription: new FormControl('', [Validators.required]),
      totalFront: new FormControl(`${totalValue}`, [Validators.required]),
      totalDepth: new FormControl(`${totalValue}`, [Validators.required]),
      totalHeight: new FormControl(`${totalValue}`, [Validators.required]),
      positionColor: new FormControl('#000000', [Validators.required]),
    });

    this.typeForm.get('type')?.valueChanges.subscribe((value) => {
      this.selectedType = value;

      let totalValue = 1.0;
      if (this.unitSystem === 'in')
        totalValue = convertMetersToInches(totalValue);

      this.typeForm.patchValue({
        totalFront: `${totalValue}`,
        totalDepth: `${totalValue}`,
        totalHeight: `${totalValue}`,
        positionTypeDescription: '',
        positionColor: '#000000',
      });

      this.layers = [];
      this.bins = [];
      this.layerGroundOffset = 0.0;

      this.gameInstance.SendMessage(
        'EventManager',
        'SelectPositionTypePrefab',
        this.selectedType
      );

      this.resetLayers();
      this.selectedLayerId = '';
      this.isSubdivision = false;
    });

    this.typeForm.get('totalHeight')?.valueChanges.subscribe((value) => {
      let height = {
        axis: 1,
        amount: +value,
      };

      if (this.unitSystem === 'in')
        height.amount = convertInchesToMeters(+value);

      this.resetLayers();

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleResizeVisualization',
        JSON.stringify(height)
      );

      this.onLevelValueChange(this.actualLayerCount);
    });

    this.typeForm.get('totalDepth')?.valueChanges.subscribe((value) => {
      const depth = {
        axis: 2,
        amount: value,
      };

      this.resetLayers();

      if (this.unitSystem === 'in')
        depth.amount = convertInchesToMeters(+value);

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleResizeVisualization',
        JSON.stringify(depth)
      );

      this.onLevelValueChange(this.actualLayerCount);
    });

    this.typeForm.get('totalFront')?.valueChanges.subscribe((value) => {
      const front = {
        axis: 0,
        amount: value,
      };

      this.resetLayers();

      if (this.unitSystem === 'in')
        front.amount = convertInchesToMeters(+value);

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleResizeVisualization',
        JSON.stringify(front)
      );

      this.onLevelValueChange(this.actualLayerCount);
    });
  }

  onLayerSeparationChange(event: any): void {
    let value = +event.target.value;

    if (this.unitSystem === 'in') value = convertInchesToMeters(value);

    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    this.actualLayerCount = 1;
    this.actualBinCount = 0;

    this.onLevelValueChange(1);

    this.layerSeparation = value;
  }

  onLevelValueChange(value: number): void {
    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    this.resetBins();
    this.layers = [];

    let totalFront = +this.typeForm.get('totalFront')?.value;
    let totalDepth = +this.typeForm.get('totalDepth')?.value;
    let totalHeight = +this.typeForm.get('totalHeight')?.value;

    if (this.unitSystem === 'in') {
      totalFront = convertInchesToMeters(totalFront);
      totalDepth = convertInchesToMeters(totalDepth);
      totalHeight = convertInchesToMeters(totalHeight);
    }

    const height = +((totalHeight - this.layerGroundOffset) / value).toFixed(2);

    let y = this.layerGroundOffset;

    for (let i = 0; i < value; i++) {
      this.layers.push({
        bins: [],
        layerDescription: `L${i}`,
        locationX: 0.0,
        locationY: y,
        locationZ: 0.0,
        totalDepth,
        totalFront,
        totalHeight: height,
        uuid: uuidv4(),
        availableSpace: height - this.layerSeparation,
      });

      this.gameInstance.SendMessage('EventManager', 'AddLayer', y.toString());
      y += height;
    }

    const type = this.typeForm.get('type')?.value;
    if (type && type === 'bin') {
      this.loadBins();
    }
  }

  setLayerHeight(id: string, event: any): void {
    this.resetBins();

    let value = +event.target.value;

    if (this.unitSystem === 'in') value = convertInchesToMeters(value);

    const index = this.layers.findIndex((x) => x.uuid! === id);
    const layer = this.layers[index];
    layer.totalHeight = value;

    let locationY = this.layerGroundOffset;

    for (let i = 0; i < index; i++) {
      const item = this.layers[i];
      locationY += item.locationY + item.totalHeight;
    }
    layer.locationY = locationY;
    locationY += layer.totalHeight;
    let totalHeight = +this.typeForm.get('totalHeight')?.value;
    if (this.unitSystem === 'in')
      totalHeight = convertInchesToMeters(totalHeight);

    const height = +(
      (totalHeight - locationY) /
      (this.layers.length - 1 - index)
    ).toFixed(2);

    for (let i = index + 1; i < this.layers.length; i++) {
      const item = this.layers[i];
      item.locationY = locationY;
      item.totalHeight = height;
      locationY += height;
    }

    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.layers.forEach((item) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'AddLayer',
        item.locationY.toString()
      );
    });
  }

  onBinValueChange(value: number): void {
    let lBins = this.bins;
    if (this.isSubdivision) {
      const layer = this.layers.find((x) => x.uuid === this.selectedLayerId);
      if (layer) lBins = layer.bins;
    }

    lBins = [];

    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    let totalFront = +this.typeForm.get('totalFront')?.value;
    let totalDepth = +this.typeForm.get('totalDepth')?.value;

    if (this.unitSystem === 'in') {
      totalFront = convertInchesToMeters(totalFront);
      totalDepth = convertInchesToMeters(totalDepth);
    }

    const front = +(totalFront / value).toFixed(2);
    let x = 0.0;

    for (let i = 0; i < value; i++) {
      lBins.push({
        totalHeight: 0.05,
        totalFront: front - this.binSeparationOffset,
        totalDepth,
        binDescription: `B${i}`,
        angle: 0.0,
        images: [],
        products: [],
        locationX: x,
        locationY: 0.0,
        locationZ: 0.0,
        uuid: uuidv4(),
      });
      this.bins = lBins;
      if (this.isSubdivision) continue;
      this.gameInstance.SendMessage(
        'EventManager',
        'HandleAddBin',
        JSON.stringify({
          locationX: x,
          totalFront: front - this.binSeparationOffset,
        })
      );
      x += front;
    }
  }

  setBinFront(id: string, event: any): void {
    let front = +event.target.value;
    if (this.unitSystem === 'in') front = convertInchesToMeters(front);

    let lBins = this.bins;
    if (this.isSubdivision) {
      const layer = this.layers.find((x) => x.uuid === this.selectedLayerId);
      if (layer) lBins = layer.bins;
    }

    const value = front + this.binSeparationOffset;
    const index = lBins.findIndex((x) => x.uuid! === id);
    const bin = lBins[index];

    if (value <= this.binSeparationOffset) {
      this.toastr.warning('Size need to be bigger then separion offset size!');
      event.target.value = bin.totalFront + this.binSeparationOffset;
      return;
    }

    bin.totalFront = value - this.binSeparationOffset;

    let locationX = 0.0;
    let totalFront = +this.typeForm.get('totalFront')?.value;
    if (this.unitSystem === 'in')
      totalFront = convertInchesToMeters(totalFront);

    if (index + 1 !== lBins.length) {
      for (let i = 0; i < index; i++) {
        const item = lBins[i];
        locationX +=
          item.locationX + item.totalFront + this.binSeparationOffset;
      }

      bin.locationX = locationX;
      locationX += bin.totalFront + this.binSeparationOffset;

      const front = parseFloat(
        ((totalFront - locationX) / (lBins.length - 1 - index)).toFixed(2)
      );

      for (let i = index + 1; i < lBins.length; i++) {
        const item = lBins[i];
        item.locationX = locationX;
        item.totalFront = front - this.binSeparationOffset;
        locationX += front;
      }
    } else {
      const antepenultimate = lBins[index - 1];

      const remainderSize =
        totalFront -
        (bin.locationX + bin.totalFront + this.binSeparationOffset);

      antepenultimate.totalFront += remainderSize;
      bin.locationX += remainderSize;
    }

    this.gameInstance.SendMessage('EventManager', 'RemoveBins');
    lBins.forEach((bin) => {
      if (this.isSubdivision) return;
      this.gameInstance.SendMessage(
        'EventManager',
        'HandleAddBin',
        JSON.stringify({ locationX: bin.locationX, totalFront: bin.totalFront })
      );
    });
  }

  onOffsetValueChange(event: any): void {
    let value = +event.target.value;
    if (this.unitSystem === 'in') value = convertInchesToMeters(value);

    this.layerGroundOffset = value;

    this.resetLayers();
    this.onLevelValueChange(this.actualLayerCount);
  }

  onBinSparationValue(event: any): void {
    let value = +event.target.value;
    if (this.unitSystem === 'in') value = convertInchesToMeters(value);
    this.binSeparationOffset = value;

    this.gameInstance.SendMessage('EventManager', 'RemoveBins');
    this.actualBinCount = 0;
    this.bins = [];
  }

  setGameInstance(event: { gameInstance: any }): void {
    this.gameInstance = event.gameInstance;
    this.gameInstanceSubject.next(this.gameInstance);
  }

  convertUnit(rawValue: number): string {
    let value = rawValue;
    if (this.unitSystem === 'in') value = convertMetersToInches(value);

    return value.toFixed(2);
  }

  private loadLayers(): void {
    this.layers.forEach((item) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'AddLayer',
        item.locationY.toString()
      );
    });
  }

  private loadBins(): void {
    this.bins.forEach((bin) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'HandleAddBin',
        JSON.stringify({ locationX: bin.locationX, totalFront: bin.totalFront })
      );
    });
  }

  private resetLayers(): void {
    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    this.actualLayerCount = 1;
    this.actualBinCount = 0;

    this.onLevelValueChange(1);

    const type = this.typeForm.get('type')?.value;
    if (type && type === 'bin') {
      this.actualBinCount = 1;
      this.onBinValueChange(1);
    }
  }

  private resetBins(): void {
    const type = this.typeForm.get('type')?.value;
    this.gameInstance.SendMessage('EventManager', 'RemoveBins');
    if (type && type === 'bin') {
      this.actualBinCount = 1;
      this.onBinValueChange(1);
    }
  }
  //set subdivision

  selectedLayerId = '';

  setSubdivision(event: any, layerId: string): void {
    this.selectedLayerId = layerId;
    this.isSubdivision = event.checked as boolean;
    const layer = this.layers.find((x) => x.uuid === layerId);
    if (layer) layer.isSubdivided = event.checked as boolean;
  }

  checkSubdivision(layerId: string) {
    const layer = this.layers.find((x) => x.uuid === layerId);
    if (this.selectedLayerId === layerId && layer?.isSubdivided)
      this.isSubdivision = true;
    else {
      if (layer) {
        if (layer.isSubdivided) {
          this.isSubdivision = true;
          this.selectedLayerId = layerId;
          this.bins = layer.bins;
        } else {
          this.isSubdivision = false;
        }
      }
    }
  }

  getSelectedLayerDescription(): string {
    const layer = this.layers.find((x) => x.uuid === this.selectedLayerId);
    if (layer) return layer.layerDescription;
    return '';
  }
}
