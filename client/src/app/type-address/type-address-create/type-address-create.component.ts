import { AfterViewInit, Component, OnDestroy, OnInit } from '@angular/core';
import {
  FormBuilder,
  FormControl,
  FormGroup,
  Validators,
} from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { Observable, of, Subject } from 'rxjs';
import { IBin } from 'src/app/shared/models/IBin';
import { ILayer } from 'src/app/shared/models/ILayer';
import { IPositionTypeMaster } from 'src/app/shared/models/IPositionTypeBin';
import { v4 as uuidv4 } from 'uuid';
import { TypeAddressService } from '../type-address.service';

@Component({
  selector: 'app-type-address-create',
  templateUrl: './type-address-create.component.html',
  styleUrls: ['./type-address-create.component.scss'],
})
export class TypeAddressCreateComponent implements OnInit, OnDestroy {
  layers: ILayer[] = [];
  bins: IBin[] = [];

  layerGroundOffset = 0;

  actualLayerCount = 0;
  actualBinCount = 0;

  typeForm!: FormGroup;
  selectedType: string = 'floor';

  gameInstance: any;

  gameInstanceSubject = new Subject<any>();
  gameInstance$: Observable<any> = this.gameInstanceSubject.asObservable();
  subscription = this.gameInstance$.subscribe(() => {
    this.gameInstance.SendMessage(
      'EventManager',
      'SelectPositionTypePrefab',
      this.selectedType
    );

    if (this.id !== -1) {
      this.typeAddressService
        .loadPositionTypeById(this.id)
        .subscribe((value) => {
          this.typeForm.patchValue(value);

          this.typeForm
            .get('positionColor')!
            .setValue('#' + value.positionColor.toString(16));

          this.positionType = value;
          this.layers = value.layers;
          this.bins = value.layers[0].bins;

          this.actualLayerCount = this.layers.length;
          this.actualBinCount = this.bins.length;

          if (this.positionType.type !== 'floor') {
            this.loadLayers();
            this.layerGroundOffset = this.layers[0].locationY;
          }
          if (this.positionType.type === 'bin') this.loadBins();
        });
    }
  });

  positionType: IPositionTypeMaster | undefined;

  id = -1;

  constructor(
    private route: Router,
    private typeAddressService: TypeAddressService,
    private activeRoute: ActivatedRoute
  ) {}

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }

  ngOnInit(): void {
    this.initForm();
    const id = this.activeRoute.snapshot.paramMap.get('id');

    if (id) {
      this.id = parseInt(id);
    }
  }

  private setLayerAndBinToFloor(positionType: IPositionTypeMaster): void {
    this.bins.push({
      binDescription: 'B01',
      totalFront: 1,
      totalHeight: 1.3,
      totalDepth: 1.2,
      angle: 0,
      locationX: 0,
      locationY: 0,
      locationZ: 0,
      images: [],
      products: [],
    });

    this.layers.push({
      layerDescription: 'L01',
      totalFront: positionType.totalFront,
      totalHeight: positionType.totalHeight,
      totalDepth: positionType.totalDepth,
      locationX: 0,
      locationY: 0,
      locationZ: 0,
      bins: [],
    });
  }

  private setBinsToRack(): void {
    this.bins.push({
      binDescription: 'B01',
      totalFront: 1,
      totalHeight: 1.3,
      totalDepth: 1.2,
      angle: 0,
      locationX: 0,
      locationY: 0,
      locationZ: 0,
      images: [],
      products: [],
    });
  }

  submit(): void {
    this.positionType = this.typeForm.value as IPositionTypeMaster;

    this.positionType.positionColor = parseInt(
      this.typeForm.get('positionColor')!.value.toString().replace('#', ''),
      16
    );
    if (this.positionType.type === 'floor')
      this.setLayerAndBinToFloor(this.positionType);
    else if (this.positionType.type === 'rack') this.setBinsToRack();

    this.layers.forEach((layer) => {
      layer.bins = this.bins;
    });
    this.positionType.layers = this.layers;
    if (this.id === -1) {
      this.typeAddressService.savePositionType(this.positionType).subscribe({
        complete: () => {
          this.route.navigate(['typeaddress']);
        },
        error: (err) => console.error(err),
      });
    } else {
      this.typeAddressService
        .updatePositionType(this.id, this.positionType)
        .subscribe({
          complete: () => {
            this.route.navigate(['typeaddress']);
          },
          error: (err) => console.error(err),
        });
    }
  }

  initForm(): void {
    this.typeForm = new FormGroup({
      type: new FormControl(this.selectedType, [Validators.required]),
      positionTypeDescription: new FormControl('', [Validators.required]),
      totalFront: new FormControl('1.0', [Validators.required]),
      totalDepth: new FormControl('1.0', [Validators.required]),
      totalHeight: new FormControl('1.0', [Validators.required]),
      positionColor: new FormControl('#000000', [Validators.required]),
    });

    this.typeForm.get('type')?.valueChanges.subscribe((value) => {
      this.selectedType = value;

      this.layers = [];
      this.bins = [];
      this.layerGroundOffset = 0.0;

      this.resetLayers();

      this.gameInstance.SendMessage(
        'EventManager',
        'SelectPositionTypePrefab',
        this.selectedType
      );
    });

    this.typeForm.get('totalHeight')?.valueChanges.subscribe((value) => {
      const height = {
        axis: 1,
        amount: value,
      };

      this.resetLayers();

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleResizeVisualization',
        JSON.stringify(height)
      );

      this.onLevelValueChange(this.actualLayerCount);
    });

    this.typeForm.get('totalDepth')?.valueChanges.subscribe((value) => {
      const depth = {
        axis: 2,
        amount: value,
      };

      this.resetLayers();

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleResizeVisualization',
        JSON.stringify(depth)
      );

      this.onLevelValueChange(this.actualLayerCount);
    });

    this.typeForm.get('totalFront')?.valueChanges.subscribe((value) => {
      const front = {
        axis: 0,
        amount: value,
      };

      this.resetLayers();

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleResizeVisualization',
        JSON.stringify(front)
      );

      this.onLevelValueChange(this.actualLayerCount);
    });
  }

  onLevelValueChange(value: number): void {
    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    this.layers = [];

    const totalFront = parseFloat(this.typeForm.get('totalFront')?.value);
    const totalDepth = parseFloat(this.typeForm.get('totalDepth')?.value);
    const totalHeight = parseFloat(this.typeForm.get('totalHeight')?.value);

    const height = parseFloat(
      ((totalHeight - this.layerGroundOffset) / value).toFixed(2)
    );

    let y = this.layerGroundOffset;

    for (let i = 0; i < value; i++) {
      this.layers.push({
        bins: [],
        layerDescription: `L${i}`,
        locationX: 0.0,
        locationY: y,
        locationZ: 0.0,
        totalDepth,
        totalFront,
        totalHeight: height,
        uuid: uuidv4(),
      });

      this.gameInstance.SendMessage('EventManager', 'AddLayer', y.toString());
      y += height;
    }
  }

  setLayerHeight(id: string, event: any): void {
    const index = this.layers.findIndex((x) => x.uuid! === id);
    const layer = this.layers[index];
    layer.totalHeight = parseFloat(event.target.value);

    let locationY = this.layerGroundOffset;

    for (let i = 0; i < index; i++) {
      const item = this.layers[i];
      locationY += item.locationY + item.totalHeight;
    }
    layer.locationY = locationY;
    locationY += layer.totalHeight;
    const totalHeight = parseFloat(this.typeForm.get('totalHeight')?.value);
    const height = parseFloat(
      ((totalHeight - locationY) / (this.layers.length - 1 - index)).toFixed(2)
    );

    for (let i = index + 1; i < this.layers.length; i++) {
      const item = this.layers[i];
      item.locationY = locationY;
      item.totalHeight = height;
      locationY += height;
    }

    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.layers.forEach((item) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'AddLayer',
        item.locationY.toString()
      );
    });
  }

  onBinValueChange(value: number): void {
    this.bins = [];

    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    const totalFront = parseFloat(this.typeForm.get('totalFront')?.value);
    const totalDepth = parseFloat(this.typeForm.get('totalDepth')?.value);

    const front = parseFloat((totalFront / value).toFixed(2));
    let x = 0.0;

    for (let i = 0; i < value; i++) {
      this.bins.push({
        totalHeight: 0.05,
        totalFront: front,
        totalDepth,
        binDescription: `B${i}`,
        angle: 0.0,
        images: [],
        products: [],
        locationX: x,
        locationY: 0.0,
        locationZ: 0.0,
        uuid: uuidv4(),
      });

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleAddBin',
        JSON.stringify({ locationX: x, totalFront: front })
      );
      x += front;
    }
  }

  setBinFront(id: string, event: any): void {
    const index = this.bins.findIndex((x) => x.uuid! === id);
    const bin = this.bins[index];
    bin.totalFront = parseFloat(event.target.value);

    let locationX = 0.0;

    for (let i = 0; i < index; i++) {
      const item = this.bins[i];
      locationX += item.locationX + item.totalFront;
    }
    bin.locationX = locationX;
    locationX += bin.totalFront;
    const totalFront = parseFloat(this.typeForm.get('totalFront')?.value);
    const front = parseFloat(
      ((totalFront - locationX) / (this.bins.length - 1 - index)).toFixed(2)
    );

    for (let i = index + 1; i < this.bins.length; i++) {
      const item = this.bins[i];
      item.locationX = locationX;
      item.totalFront = front;
      locationX += front;
    }

    this.gameInstance.SendMessage('EventManager', 'RemoveBins');
    this.bins.forEach((bin) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'HandleAddBin',
        JSON.stringify({ locationX: bin.locationX, totalFront: bin.totalFront })
      );
    });
  }

  onOffsetValueChange(event: any): void {
    const value = parseFloat(event.target.value);
    this.layerGroundOffset = value;

    this.resetLayers();
    this.onLevelValueChange(this.actualLayerCount);
  }

  setGameInstance(event: { gameInstance: any }): void {
    this.gameInstance = event.gameInstance;
    this.gameInstanceSubject.next(this.gameInstance);
  }

  private loadLayers(): void {
    this.layers.forEach((item) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'AddLayer',
        item.locationY.toString()
      );
    });
  }

  private loadBins(): void {
    this.bins.forEach((bin) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'HandleAddBin',
        JSON.stringify({ locationX: bin.locationX, totalFront: bin.totalFront })
      );
    });
  }

  private resetLayers(): void {
    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    this.actualLayerCount = 0;
    this.actualBinCount = 0;
  }
}
