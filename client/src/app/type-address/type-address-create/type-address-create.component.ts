import {
  AfterViewInit,
  Component,
  ElementRef,
  OnDestroy,
  OnInit,
  ViewChild,
} from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { Observable, Subject } from 'rxjs';

import {
  WebGLRenderer,
  PerspectiveCamera,
  Scene,
  BoxGeometry,
  MeshBasicMaterial,
  Mesh,
  Color,
} from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { ToastrService } from 'ngx-toastr';
import { v4 as uuidv4 } from 'uuid';

import { TypeAddressService } from '../type-address.service';
import { IBin } from 'src/app/shared/models/IBin';
import { ILayer } from 'src/app/shared/models/ILayer';
import { IPositionTypeMaster } from 'src/app/shared/models/IPositionTypeBin';

@Component({
  selector: 'app-type-address-create',
  templateUrl: './type-address-create.component.html',
  styleUrls: ['./type-address-create.component.scss'],
})
export class TypeAddressCreateComponent implements OnInit, OnDestroy {
  layers: ILayer[] = [];
  bins: IBin[] = [];

  layerGroundOffset = 0;

  binSeparationOffset = 0;
  layerSeparation = 0;

  actualLayerCount = 0;
  actualBinCount = 0;

  typeForm!: FormGroup;
  selectedType: string = 'floor';

  gameInstance: any;

  unitSystem = 'm';

  // @ViewChild('canvas', { static: false }) canvasRef?: ElementRef;

  private gameInstanceSubject = new Subject<any>();
  gameInstance$: Observable<any> = this.gameInstanceSubject.asObservable();

  subscription = this.gameInstance$.subscribe(() => {
    this.gameInstance.SendMessage(
      'EventManager',
      'SelectPositionTypePrefab',
      this.selectedType
    );

    if (this.id !== -1) {
      this.typeAddressService
        .loadPositionTypeById(this.id)
        .subscribe((value) => {
          this.typeForm.patchValue(value);

          this.typeForm
            .get('positionColor')!
            .setValue('#' + value.positionColor.toString(16));

          this.positionType = value;
          this.layers = value.layers;
          this.bins = value.layers[0].bins;

          this.actualLayerCount = this.layers.length;
          this.actualBinCount = this.bins.length;

          if (this.positionType.type !== 'floor') {
            this.layerGroundOffset = this.layers[0].locationY;
            this.loadLayers();
          }
          if (this.positionType.type === 'bin') {
            this.binSeparationOffset = this.bins[0].locationZ;
            this.loadBins();
          }
        });
    }
  });

  positionType: IPositionTypeMaster | undefined;

  id = -1;

  constructor(
    private route: Router,
    private typeAddressService: TypeAddressService,
    private activeRoute: ActivatedRoute,
    private toastr: ToastrService
  ) {}

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }

  ngOnInit(): void {
    this.initForm();
    const id = this.activeRoute.snapshot.paramMap.get('id');

    if (id) {
      this.id = parseInt(id);
    }
  }

  private setLayerAndBinToFloor(positionType: IPositionTypeMaster): void {
    this.bins.push({
      binDescription: 'B01',
      totalFront: 1,
      totalHeight: 1.3,
      totalDepth: 1.2,
      angle: 0,
      locationX: 0,
      locationY: 0,
      locationZ: 0,
      images: [],
      products: [],
    });

    this.layers.push({
      layerDescription: 'L01',
      totalFront: positionType.totalFront,
      totalHeight: positionType.totalHeight,
      totalDepth: positionType.totalDepth,
      locationX: 0,
      locationY: 0,
      locationZ: 0,
      bins: [],
      availableSpace: positionType.totalHeight,
    });
  }

  private setBinsToRack(): void {
    this.bins.push({
      binDescription: 'B01',
      totalFront: 1,
      totalHeight: 1.3,
      totalDepth: 1.2,
      angle: 0,
      locationX: 0,
      locationY: 0,
      locationZ: 0,
      images: [],
      products: [],
    });
  }

  submit(): void {
    this.positionType = this.typeForm.value as IPositionTypeMaster;

    this.positionType.positionColor = parseInt(
      this.typeForm.get('positionColor')!.value.toString().replace('#', ''),
      16
    );
    if (this.positionType.type === 'floor')
      this.setLayerAndBinToFloor(this.positionType);
    else if (this.positionType.type === 'rack') this.setBinsToRack();
    else {
      this.bins[0].locationZ = this.binSeparationOffset;
    }

    this.layers.forEach((layer) => {
      layer.bins = this.bins;
    });
    this.positionType.layers = this.layers;
    if (this.id === -1) {
      this.typeAddressService.savePositionType(this.positionType).subscribe({
        complete: () => {
          this.route.navigate(['typeaddress']);
        },
        error: (err) => console.error(err),
      });
    } else {
      this.typeAddressService
        .updatePositionType(this.id, this.positionType)
        .subscribe({
          complete: () => {
            this.route.navigate(['typeaddress']);
          },
          error: (err) => console.error(err),
        });
    }
  }

  initForm(): void {
    this.typeForm = new FormGroup({
      type: new FormControl(this.selectedType, [Validators.required]),
      positionTypeDescription: new FormControl('', [Validators.required]),
      totalFront: new FormControl('1.0', [Validators.required]),
      totalDepth: new FormControl('1.0', [Validators.required]),
      totalHeight: new FormControl('1.0', [Validators.required]),
      positionColor: new FormControl('#000000', [Validators.required]),
    });

    this.typeForm.get('type')?.valueChanges.subscribe((value) => {
      this.selectedType = value;

      this.typeForm.patchValue({
        totalFront: 1.0,
        totalDepth: 1.0,
        totalHeight: 1.0,
        positionTypeDescription: '',
        positionColor: '#000000',
      });

      this.layers = [];
      this.bins = [];
      this.layerGroundOffset = 0.0;

      this.gameInstance.SendMessage(
        'EventManager',
        'SelectPositionTypePrefab',
        this.selectedType
      );

      this.resetLayers();
    });

    this.typeForm.get('totalHeight')?.valueChanges.subscribe((value) => {
      const height = {
        axis: 1,
        amount: value,
      };

      this.resetLayers();

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleResizeVisualization',
        JSON.stringify(height)
      );

      this.onLevelValueChange(this.actualLayerCount);
    });

    this.typeForm.get('totalDepth')?.valueChanges.subscribe((value) => {
      const depth = {
        axis: 2,
        amount: value,
      };

      this.resetLayers();

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleResizeVisualization',
        JSON.stringify(depth)
      );

      this.onLevelValueChange(this.actualLayerCount);
    });

    this.typeForm.get('totalFront')?.valueChanges.subscribe((value) => {
      const front = {
        axis: 0,
        amount: value,
      };

      this.resetLayers();

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleResizeVisualization',
        JSON.stringify(front)
      );

      this.onLevelValueChange(this.actualLayerCount);
    });
  }

  onLayerSeparationChange(event: any): void {
    const value = +event.target.value;

    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    this.actualLayerCount = 1;
    this.actualBinCount = 0;

    this.onLevelValueChange(1);

    this.layerSeparation = value;
  }

  onLevelValueChange(value: number): void {
    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    this.layers = [];

    const totalFront = +this.typeForm.get('totalFront')?.value;
    const totalDepth = +this.typeForm.get('totalDepth')?.value;
    const totalHeight = +this.typeForm.get('totalHeight')?.value;

    const height = +((totalHeight - this.layerGroundOffset) / value).toFixed(2);

    let y = this.layerGroundOffset;

    for (let i = 0; i < value; i++) {
      this.layers.push({
        bins: [],
        layerDescription: `L${i}`,
        locationX: 0.0,
        locationY: y,
        locationZ: 0.0,
        totalDepth,
        totalFront,
        totalHeight: height,
        uuid: uuidv4(),
        availableSpace: height - this.layerSeparation,
      });

      this.gameInstance.SendMessage('EventManager', 'AddLayer', y.toString());
      y += height;
    }


    const type = this.typeForm.get('type')?.value;
    if (type && type === 'bin') {
      this.loadBins();
    }
  }

  setLayerHeight(id: string, event: any): void {
    const index = this.layers.findIndex((x) => x.uuid! === id);
    const layer = this.layers[index];
    layer.totalHeight = parseFloat(event.target.value);

    let locationY = this.layerGroundOffset;

    for (let i = 0; i < index; i++) {
      const item = this.layers[i];
      locationY += item.locationY + item.totalHeight;
    }
    layer.locationY = locationY;
    locationY += layer.totalHeight;
    const totalHeight = parseFloat(this.typeForm.get('totalHeight')?.value);
    const height = parseFloat(
      ((totalHeight - locationY) / (this.layers.length - 1 - index)).toFixed(2)
    );

    for (let i = index + 1; i < this.layers.length; i++) {
      const item = this.layers[i];
      item.locationY = locationY;
      item.totalHeight = height;
      locationY += height;
    }

    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.layers.forEach((item) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'AddLayer',
        item.locationY.toString()
      );
    });
  }

  onBinValueChange(value: number): void {
    this.bins = [];

    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    const totalFront = +this.typeForm.get('totalFront')?.value;
    const totalDepth = +this.typeForm.get('totalDepth')?.value;

    const front = +(totalFront / value).toFixed(2);
    let x = 0.0;

    for (let i = 0; i < value; i++) {
      this.bins.push({
        totalHeight: 0.05,
        totalFront: front - this.binSeparationOffset,
        totalDepth,
        binDescription: `B${i}`,
        angle: 0.0,
        images: [],
        products: [],
        locationX: x,
        locationY: 0.0,
        locationZ: 0.0,
        uuid: uuidv4(),
      });

      this.gameInstance.SendMessage(
        'EventManager',
        'HandleAddBin',
        JSON.stringify({
          locationX: x,
          totalFront: front - this.binSeparationOffset,
        })
      );
      x += front;
    }
  }

  setBinFront(id: string, event: any): void {
    const value = +event.target.value + this.binSeparationOffset;
    const index = this.bins.findIndex((x) => x.uuid! === id);
    const bin = this.bins[index];

    if (value <= this.binSeparationOffset) {
      this.toastr.warning('Size need to be bigger then separion offset size!');
      event.target.value = bin.totalFront + this.binSeparationOffset;
      return;
    }

    bin.totalFront = value - this.binSeparationOffset;

    let locationX = 0.0;

    for (let i = 0; i < index; i++) {
      const item = this.bins[i];
      locationX += item.locationX + item.totalFront + this.binSeparationOffset;
    }

    bin.locationX = locationX;
    locationX += bin.totalFront + this.binSeparationOffset;

    const totalFront = parseFloat(this.typeForm.get('totalFront')?.value);
    const front = parseFloat(
      ((totalFront - locationX) / (this.bins.length - 1 - index)).toFixed(2)
    );

    for (let i = index + 1; i < this.bins.length; i++) {
      const item = this.bins[i];
      item.locationX = locationX;
      item.totalFront = front - this.binSeparationOffset;
      locationX += front;
    }

    this.gameInstance.SendMessage('EventManager', 'RemoveBins');
    this.bins.forEach((bin) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'HandleAddBin',
        JSON.stringify({ locationX: bin.locationX, totalFront: bin.totalFront })
      );
    });
  }

  onOffsetValueChange(event: any): void {
    const value = parseFloat(event.target.value);
    this.layerGroundOffset = value;

    this.resetLayers();
    this.onLevelValueChange(this.actualLayerCount);
  }

  onBinSparationValue(event: any): void {
    const value = parseFloat(event.target.value);
    this.binSeparationOffset = value;

    this.gameInstance.SendMessage('EventManager', 'RemoveBins');
    this.actualBinCount = 0;
    this.bins = [];
  }

  setGameInstance(event: { gameInstance: any }): void {
    this.gameInstance = event.gameInstance;
    this.gameInstanceSubject.next(this.gameInstance);
  }

  private loadLayers(): void {
    this.layers.forEach((item) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'AddLayer',
        item.locationY.toString()
      );
    });
  }

  private loadBins(): void {
    this.bins.forEach((bin) => {
      this.gameInstance.SendMessage(
        'EventManager',
        'HandleAddBin',
        JSON.stringify({ locationX: bin.locationX, totalFront: bin.totalFront })
      );
    });
  }

  private resetLayers(): void {
    this.gameInstance.SendMessage('EventManager', 'RemoveLayers');
    this.gameInstance.SendMessage('EventManager', 'RemoveBins');

    this.actualLayerCount = 1;
    this.actualBinCount = 0;

    this.onLevelValueChange(1);

    const type = this.typeForm.get('type')?.value;
    if (type && type === 'bin') {
      this.actualBinCount = 1;
      this.onBinValueChange(1);
    }
  }
}
