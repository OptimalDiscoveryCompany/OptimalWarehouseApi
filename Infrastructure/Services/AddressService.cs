using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Core.Dtos.Address;
using Core.Entities;
using Core.Interfaces;
using Core.Interfaces.Services;
using Core.Specification.AddressSpecification;

namespace Infrastructure.Services
{
    public class AddressService : IAddressService
    {
        private readonly IUnitOfWork _unitOfWork;

        public AddressService(IUnitOfWork unitOfWork)
        {
            _unitOfWork = unitOfWork;
        }

        public async Task<IReadOnlyList<Address3D>> ListAllAddress3DAsync()
        {
            var spec = new AddressWithIncludes();
            var addresses = await _unitOfWork.Repository<TPickingAddressMaster>().ListAsync(spec);


            var address3dList = new List<Address3D>();
            foreach (var address in addresses)
            {
                var address3d = new Address3D
                {
                    AddressId = address.AddressId,
                    Id = address.Id,
                    LocationX = address.LocationX.Value,
                    LocationY = address.LocationY.Value,
                    PickingAccess = (int)address.PickingAccess,
                    PickingAccessIsAccessable = address.PickingAccessIsAccessable,
                    PositionTypeDescription = address.PickingAreaDescription,
                    PositionType = address.PositionType,
                    TotalDepth = address.TotalDepth.Value,
                    TotalFront = address.TotalFront.Value,
                    TotalHeight = address.TotalHeight.Value
                };

                var layers = new List<Layer3D>();
                foreach (var layer in address.Layers)
                {
                    var nLayer = new Layer3D
                    {
                        Angle = 0.0f,
                        LocationX = layer.LocationX,
                        LocationY = layer.LocationY,
                        LocationZ = layer.LocationZ,
                        TotalDepth = layer.TotalDepth,
                        TotalFront = layer.TotalFront,
                        TotalHeight = layer.TotalHeight
                    };


                    var bins = new List<Bin3D>();
                    foreach (var bin in layer.Bins)
                    {
                        bins.Add(
                            new Bin3D
                            {
                                Images = null,
                                Products = null,
                                LocationX = bin.LocationX,
                                LocationY = bin.LocationZ,
                                LocationZ = bin.LocationZ,
                                TotalDepth = bin.TotalDepth,
                                TotalFront = bin.TotalFront,
                                TotalHeight = bin.TotalHeight
                            }
                        );
                    }
                    nLayer.Bins = bins;

                    layers.Add(nLayer);
                }

                address3d.Layers = layers;
                address3dList.Add(address3d);
            }



            return address3dList;
        }

        public async Task<IReadOnlyList<AddressDto>> ListAllAddressAsync()
        {
            var addresses = await _unitOfWork.Repository<TPickingAddressMaster>().ListAllAsync();
            List<AddressDto> addressesDto = new();
            foreach (var address in addresses)
            {
                addressesDto.Add(
                    new AddressDto
                    {
                        AddressId = address.AddressId,
                        Id = address.Id,
                        LocationX = address.LocationX,
                        LocationY = address.LocationY,
                        PickingAccess = address.PickingAccess,
                        Sequence = address.Sequence,
                        TotalDepth = address.TotalDepth,
                        TotalFront = address.TotalFront,
                        TotalHeight = address.TotalHeight,
                        PositionTypeDescription = address.PositionTypeDescription,
                        Color = address.Color,
                        PickingAccessIsAccessable = address.PickingAccessIsAccessable,
                        PositionType = address.PositionType
                    }
                );
            }

            return addressesDto;

        }

        public async Task<bool> RegisterAddressesAsync(List<AddressRegisterDto> addressesRegisters)
        {
            var addresses = await _unitOfWork.Repository<TPickingAddressMaster>().ListAllAsync();
            _unitOfWork.Repository<TPickingAddressMaster>().DeleteRange(addresses.ToList());
            var result = await _unitOfWork.Complete();
            if (result < 0)
                return false;
            foreach (var register in addressesRegisters)
            {
                TPickingAddressMaster newAddress = new TPickingAddressMaster
                {
                    AddressId = register.AddressId,
                    LocationId = "B028",
                    PickingAreaDescription = "Actual",
                    LocationX = register.LocationX,
                    LocationY = register.LocationY,
                    PickingAccess = register.PickingAccess,
                    PositionTypeDescription = register.PositionTypeDescription,
                    TotalFront = register.TotalFront,
                    TotalDepth = register.TotalDepth,
                    TotalHeight = register.TotalHeight,
                    Sequence = register.Sequence,
                    PickingAccessIsAccessable = register.PickingAccessIsAccessable,
                    Color = register.Color
                };


                var spec = new PositionTypeByTypeWithIncludes(register.PositionType);
                var positionType = await _unitOfWork.Repository<TPickingPositionTypeMaster>().GetEntityWithSpecs(spec);

                newAddress.PositionTypeDescription = positionType.PositionTypeDescription;
                newAddress.TotalFront = positionType.TotalFront;
                newAddress.TotalDepth = positionType.TotalDepth;
                newAddress.TotalHeight = positionType.TotalHeight;
                newAddress.PositionType = positionType.Type;


                var layers = new List<TPickingAddressLayer>();
                positionType.Layers.ForEach(layer =>
                {
                    var nLayer = new TPickingAddressLayer
                    {
                        LayerDescription = layer.LayerDescription,
                        LocationX = layer.LocationX,
                        LocationY = layer.LocationY,
                        LocationZ = layer.LocationZ,
                        TotalDepth = layer.TotalDepth,
                        TotalFront = layer.TotalFront,
                        TotalHeight = layer.TotalHeight,
                    };

                    var bins = new List<TPickingAddressBin>();
                    layer.Bins.ForEach(bin =>
                    {
                        bins.Add(new TPickingAddressBin
                        {
                            Angle = bin.Angle,
                            BinDescription = bin.BinDescription,
                            LocationX = bin.LocationX,
                            LocationY = bin.LocationY,
                            LocationZ = bin.LocationZ,
                            TotalDepth = bin.TotalDepth,
                            TotalFront = bin.TotalFront,
                            TotalHeight = bin.TotalHeight,
                        });
                    });

                    nLayer.Bins = bins;
                    layers.Add(nLayer);
                });
                newAddress.Layers = layers;
                _unitOfWork.Repository<TPickingAddressMaster>().Add(newAddress);

            }

            result = await _unitOfWork.Complete();
            if (result < 0)
                return false;
            return true;

        }

        public async Task<bool> RemoveAddressesAsync(List<AddressDto> addressesRemove)
        {
            var addresses = new List<TPickingAddressMaster>();
            foreach (var rem in addressesRemove)
            {
                var markToRemove = await _unitOfWork.Repository<TPickingAddressMaster>().GetByIdAsync(rem.Id);
                addresses.Add(markToRemove);
            }
            _unitOfWork.Repository<TPickingAddressMaster>().DeleteRange(addresses);
            var result = await _unitOfWork.Complete();
            if (result <= 0)
                return false;
            return true;


        }
    }
}