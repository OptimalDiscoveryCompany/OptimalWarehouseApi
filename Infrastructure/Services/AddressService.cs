using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Core.Dtos.Address;
using Core.Entities;
using Core.Interfaces;
using Core.Interfaces.Services;
using Core.Specification.AddressSpecification;

namespace Infrastructure.Services
{
    public class AddressService : IAddressService
    {
        private readonly IUnitOfWork _unitOfWork;

        public AddressService(IUnitOfWork unitOfWork)
        {
            _unitOfWork = unitOfWork;
        }

        public async Task<IReadOnlyList<AddressDto>> ListAllAddressAsync()
        {
            var addresses = await _unitOfWork.Repository<TPickingAddressMaster>().ListAllAsync();
            List<AddressDto> addressesDto = new();
            foreach (var address in addresses)
            {
                addressesDto.Add(
                    new AddressDto
                    {
                        AddressId = address.AddressId,
                        Id = address.Id,
                        LocationX = address.LocationX,
                        LocationY = address.LocationY,
                        PickingAccess = address.PickingAccess,
                        Sequence = address.Sequence,
                        TotalDepth = address.TotalDepth,
                        TotalFront = address.TotalFront,
                        TotalHeight = address.TotalHeight,
                        PositionTypeDescription = address.PositionTypeDescription
                    }
                );
            }

            return addressesDto;

        }

        public async Task<bool> RegisterAddressesAsync(List<AddressRegisterDto> addressesRegisters)
        {
            var addresses = await _unitOfWork.Repository<TPickingAddressMaster>().ListAllAsync();
            _unitOfWork.Repository<TPickingAddressMaster>().DeleteRange(addresses.ToList());
            var result = await _unitOfWork.Complete();
            if (result < 0)
                return false;
            foreach (var register in addressesRegisters)
            {
                TPickingAddressMaster newAddress = new TPickingAddressMaster
                {
                    AddressId = register.AddressId,
                    LocationId = "B028",
                    PickingAreaDescription = "Actual",
                    LocationX = register.LocationX,
                    LocationY = register.LocationY,
                    PickingAccess = register.PickingAccess,
                    PositionTypeDescription = register.PositionTypeDescription,
                    TotalFront = register.TotalFront,
                    TotalDepth = register.TotalDepth,
                    TotalHeight = register.TotalHeight,
                    Sequence = register.Sequence

                };


                var spec = new PositionTypeByIdWithIncludes(register.PositionTypeId);
                var positionType = await _unitOfWork.Repository<TPickingPositionTypeMaster>().GetEntityWithSpecs(spec);

                newAddress.PositionTypeDescription = positionType.PositionTypeDescription;
                newAddress.TotalFront = positionType.TotalFront;
                newAddress.TotalDepth = positionType.TotalDepth;
                newAddress.TotalHeight = positionType.TotalHeight;
                newAddress.Type = positionType.Type;


                var layers = new List<TPickingAddressLayer>();
                positionType.Layers.ForEach(layer =>
                {
                    var nLayer = new TPickingAddressLayer
                    {
                        LayerDescription = layer.LayerDescription,
                        LocationX = layer.LocationX,
                        LocationY = layer.LocationY,
                        LocationZ = layer.LocationZ,
                        TotalDepth = layer.TotalDepth,
                        TotalFront = layer.TotalFront,
                        TotalHeight = layer.TotalHeight,
                    };

                    var bins = new List<TPickingAddressBin>();
                    layer.Bins.ForEach(bin =>
                    {
                        bins.Add(new TPickingAddressBin
                        {
                            Angle = bin.Angle,
                            BinDescription = bin.BinDescription,
                            LocationX = bin.LocationX,
                            LocationY = bin.LocationY,
                            LocationZ = bin.LocationZ,
                            TotalDepth = bin.TotalDepth,
                            TotalFront = bin.TotalFront,
                            TotalHeight = bin.TotalHeight,
                        });
                    });
                });

                _unitOfWork.Repository<TPickingAddressMaster>().Add(newAddress);

            }

            result = await _unitOfWork.Complete();
            if (result < 0)
                return false;
            return true;

        }

        public async Task<bool> RemoveAddressesAsync(List<AddressDto> addressesRemove)
        {
            var addresses = new List<TPickingAddressMaster>();
            foreach (var rem in addressesRemove)
            {
                var markToRemove = await _unitOfWork.Repository<TPickingAddressMaster>().GetByIdAsync(rem.Id);
                addresses.Add(markToRemove);
            }
            _unitOfWork.Repository<TPickingAddressMaster>().DeleteRange(addresses);
            var result = await _unitOfWork.Complete();
            if (result <= 0)
                return false;
            return true;


        }
    }
}